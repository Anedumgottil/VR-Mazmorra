using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//manages (or will manage) an Array of GridSpaces that contain either a Tile or a Block.
//Blocks are the voxel-based Prefabs that are pre-generated by the BlockPrefabGenerator in the Editor
//Tiles are the normal map tiles that will make up the main part of the game.

public class MapGrid : MonoBehaviour {
	
    private static MapGrid instance = null;//now with 100% more singleton!
    public bool shouldRender = true;//TODO: what is shouldRender?
    public Vector3 position;
    public static int gridSize = 2;//meters, Size of GridSpace. used to determine scaling of Grid.
	public int xDimension = 20;
	public int yDimension = 20;
	public bool drawGizmos = true;
	public bool drawIconGizmos = true;
    public bool drawBlockGizmos = false; //gizmos will be drawn for instantiated blocks that exist in memory (thusly, only during game run)
	public Texture2D icon;
    private GridSpace[,] grid;//TODO: make this not 2 dimensional, Unity serializer is the literal embodiment of human suffering it can't handle simple multidimensional arrays (which are stored linearly in memory ffs)

    private MapGrid() {
        //for our 8-block array, we'll have Y be up, Z be forward, and X be lateral.
        //forward direction is northern/southern movement, lateral is east/west. +x = West, +z = North
        grid = new GridSpace[xDimension, yDimension];
    }

    void Awake() {
        //Check if instance already exists
        if (instance == null)
            instance = this;

        //If instance already exists and it's not this:
        else if (instance != this)
            //Then destroy this. This enforces our singleton pattern, meaning there can only ever be one instance of a MapGrid.
            Destroy (gameObject); 
    }

    //use this to get da grid
    public static MapGrid getInstance() {
        //grid tha new wave now. grid the tsunami
        return instance;
    }
        
    public static int getSize() {
        return gridSize;
    }

    //sets the GridSpace at x, y to gs. Updates the positions for gs accordingly, and sets parents.
    //overwrites whatever was in the spot before it.
    public void registerGridSpace(int x, int y, GridSpace gs) {
        if (x >= xDimension || x < 0 || y >= yDimension || y < 0) {
            Debug.LogWarning ("Warning: Attempted to register a GridSpace out of bounds ("+x+", "+y+"), destroying GridSpace!");
            gs.destroy ();
            return;
        }
        gs.setBothPositions (new Vector2 (x, y));
        gs.setParents (this);
        grid [x, y] = gs;
    }

    //returns whatever is at that position, may return null if none exists
    public GridSpace getGridSpace(int x, int y) {
        if (x >= xDimension || x < 0 || y >= yDimension || y < 0) {
            Debug.LogWarning ("Warn: Attempted to get a GridSpace out of bounds ("+x+", "+y+")");
            return null;
        }
        return grid [x, y];
    }
    //returns whatever is at that position, even if it's out of bounds (just returns null in that case) with disabled warning, because the MapGenerator regularly asks for non-existent coordinates. and this is okay in that case.
    public GridSpace getGridSpace(int x, int y, bool suppressWarning) {
        if (x >= xDimension || x < 0 || y >= yDimension || y < 0) {
            if (!suppressWarning) {
                Debug.LogWarning ("Warn: Attempted to get a GridSpace out of bounds (" + x + ", " + y + ")");
            }
            return null;
        }
        return grid [x, y];
    }

    public bool isOccupied(Vector2Int low, Vector2Int high) {
        int lowX = low.x;
        int lowY = low.y;
        int highX = high.x;
        int highY = high.y;

        if (high.x < lowX) {//this case should never happen, but we gotta check for it and fix it because we cant return null
            lowX = high.x;
            Debug.LogWarning ("MapGrid: isOccupied: Specified out of order coordinates for low x");
        }
        if (high.y < lowY) {//this case should never happen, but we gotta check for it and fix it because we cant return null
            lowY = high.y;
            Debug.LogWarning ("MapGrid: isOccupied: Specified out of order coordinates for low y");
        }
        if (low.x > highX) {//this case should never happen, but we gotta check for it and fix it because we cant return null
            highX = low.x;
            Debug.LogWarning ("MapGrid: isOccupied: Specified out of order coordinates for high x");
        }
        if (low.y > highY) {//this case should never happen, but we gotta check for it and fix it because we cant return null
            highY = low.y;
            Debug.LogWarning ("MapGrid: isOccupied: Specified out of order coordinates for high y");
        }
            
        //begin meat & potatoes
        for (int i = lowX; i < highX; i++) {
            for (int j = lowY; j < highY; j++) {
                if (isOccupied (i, j))
                    return true;
            }
        }
        return false;
    }

    //helper wrapper function for getGridSpace
    public bool isOccupied(int x, int y) {
        if (getGridSpace (x, y, true) == null) {
            return false;
        }
        return true;
    }

    void OnDrawGizmos() {
        if (drawGizmos) {
            for (int x = xDimension-1; x >= 0; x--) {
                for (int y = yDimension-1; y >= 0; y--) {
                    Func<float, float, float> dimensionPos = (float offset, float distance) => (offset + distance * gridSize) + (gridSize / 2);
                    //it's weird, but we want the x and y dimensions of our grid to be laid over the x and z dimensions in Unity.
                    if (drawIconGizmos) {
                        Gizmos.DrawIcon (new Vector3 (dimensionPos (transform.position.x, x), transform.position.y, dimensionPos (transform.position.z, y)), icon.name, false);
                    } else {
                        Gizmos.color = Color.white;
                        Gizmos.DrawSphere (new Vector3 (dimensionPos (transform.position.x, x), transform.position.y, dimensionPos (transform.position.z, y)), 0.025f);
                    }
                }
            }
        }
    }

    //HELPER FUNCTIONS:
    public Vector3 getWorldCoordsFromGridCoords(int x, int y) {
        if (this.gameObject == null)
            return new Vector3();
        return new Vector3 (x*MapGrid.getSize(), this.gameObject.transform.position.y+(MapGrid.getSize()*1.5f), y*MapGrid.getSize());
    }
    public Vector3 getWorldCoordsFromGridCoords(Vector2Int v) {
        if (this.gameObject == null)
            return new Vector3();
        return getWorldCoordsFromGridCoords(v.x, v.y);
    }

    public static Vector2Int getGridCoordsFromWorldCoords(Vector3 v) {
        return new Vector2Int ((int)v.x/MapGrid.getSize(), (int)v.z/MapGrid.getSize());
    }

    public static float getHeading(Transform t) {
        Vector3 forward = t.forward;
        forward.y = 0;
        return Quaternion.LookRotation(forward).eulerAngles.y;
    }  
    //gets a vector like (0,0,1) from a vector like (0.2, -0.4, 0.95)
    public static Vector3Int roundVectorToCardinal(Vector3 v) {
        //Debug.Log ("Rounding vector " + v.ToString ());
        int count = 0;
        float high = 0.0f;
        int target = 0;
        for( int i = 0; i < 3; i ++) {
            if (Mathf.Abs(v[i]) > high) {
                high = Mathf.Abs(v[i]);
                target = count;
            }
            count++;
        }
        Vector3Int toRet = Vector3Int.zero;
        if (v[target] < 0.0f) {
            toRet [target] = -1;
        } else {
            toRet[target] = 1;
        }
        //Debug.Log ("Rounded vector " + toRet.ToString ());
        return toRet;
    }
    //completely ignores the y component.
    public static Vector2Int roundVectorToCardinalIgnoreY(Vector3 v) {
        v.y = 0.0f;
        Vector3Int vround = roundVectorToCardinal (v);
        return new Vector2Int (vround.x, vround.z);
    }
}

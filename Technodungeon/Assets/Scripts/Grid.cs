using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

//manages (or will manage) an Array of GridSpaces that contain either a Tile or a Block.
//Blocks are the voxel-based Prefabs that are pre-generated by the BlockPrefabGenerator in the Editor
//Tiles are the normal map tiles that will make up the main part of the game.

public class Grid : MonoBehaviour {
	
    private static Grid instance = null;//now with 100% more singleton!
    public bool shouldRender = true;//TODO: what is shouldRender?
    public Vector3 position;
    public static int gridSize = 2;//meters
	public int xDimension = 20;
	public int yDimension = 20;
	public bool drawGizmos = true;
	public bool drawIconGizmos = true;
    public bool drawBlockGizmos = false; //gizmos will be drawn for instantiated blocks that exist in memory (thusly, only during game run)
	public Texture2D icon;
    private GridSpace[,] grid;//TODO: make this not 2 dimensional, Unity serializer is the literal embodiment of human suffering it can't handle simple multidimensional arrays (which are stored linearly in memory ffs)

    private Grid() {
        //for our 8-block array, we'll have Y be up, Z be forward, and X be lateral.
        //forward direction is northern/southern movement, lateral is east/west. +x = West, +z = North
        grid = new GridSpace[xDimension, yDimension];
    }

    void Awake() {
        //Check if instance already exists
        if (instance == null)
            instance = this;

        //If instance already exists and it's not this:
        else if (instance != this)
            //Then destroy this. This enforces our singleton pattern, meaning there can only ever be one instance of a Grid.
            Destroy (gameObject); 
    }

    //use this to get da grid
    public static Grid getInstance() {
        //grid tha new wave now. grid the tsunami
        return instance;
    }
        
    public static int getSize() {
        return gridSize;
    }

    public void registerGridSpace(int x, int y, GridSpace gs) {
        if (x >= xDimension || x < 0 || y >= yDimension || y < 0) {
            Debug.LogError ("Error: Attempted to register a GridSpace out of bounds ("+x+", "+y+"), destroying GridSpace!");
            gs.destroy ();
            return;
        }
        gs.setBothPositions (new Vector2 (x, y));
        gs.setParents (this);
        grid [x, y] = gs;
    }

    //returns whatever is at that position, may return null if none exists
    public GridSpace getGridSpace(int x, int y) {
        if (x >= xDimension || x < 0 || y >= yDimension || y < 0) {
            Debug.LogWarning ("Warn: Attempted to get a GridSpace out of bounds ("+x+", "+y+")");
            return null;
        }
        return grid [x, y];
    }
    //returns whatever is at that position, even if it's out of bounds (just returns null in that case) with disabled warning, because the MapGenerator regularly asks for non-existent coordinates. and this is okay in that case.
    public GridSpace getGridSpace(int x, int y, bool suppressWarning) {
        if (x >= xDimension || x < 0 || y >= yDimension || y < 0) {
            if (!suppressWarning) {
                Debug.LogWarning ("Warn: Attempted to get a GridSpace out of bounds (" + x + ", " + y + ")");
            }
            return null;
        }
        return grid [x, y];
    }

	void OnDrawGizmos() {
        if (drawGizmos) {
            for (int x = xDimension-1; x >= 0; x--) {
                for (int y = yDimension-1; y >= 0; y--) {
                    Func<float, float, float> dimensionPos = (float offset, float distance) => (offset + distance * gridSize) + (gridSize / 2);
                    //it's weird, but we want the x and y dimensions of our grid to be laid over the x and z dimensions in Unity.
                    if (drawIconGizmos) {
                        Gizmos.DrawIcon (new Vector3 (dimensionPos (transform.position.x, x), transform.position.y, dimensionPos (transform.position.z, y)), icon.name, false);
                    } else {
                        Gizmos.color = Color.white;
                        Gizmos.DrawSphere (new Vector3 (dimensionPos (transform.position.x, x), transform.position.y, dimensionPos (transform.position.z, y)), 0.025f);
                    }
                }
            }
        }
    }

}
